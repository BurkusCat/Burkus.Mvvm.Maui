using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

namespace Burkus.Mvvm.Maui;

[Generator]
public class PageSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization required
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Get the compilation object that represents the user code
        var compilation = context.Compilation;

        // Get the symbols for the base types
        var contentPageSymbol = compilation.GetTypeByMetadataName("Microsoft.Maui.Controls.ContentPage");
        var flyoutPageSymbol = compilation.GetTypeByMetadataName("Microsoft.Maui.Controls.FlyoutPage");
        var navigationPageSymbol = compilation.GetTypeByMetadataName("Microsoft.Maui.Controls.NavigationPage");
        var tabbedPageSymbol = compilation.GetTypeByMetadataName("Microsoft.Maui.Controls.TabbedPage");

        var skipBackButtonGenerationSymbol = compilation.GetTypeByMetadataName("Burkus.Mvvm.Maui.DisableBackButtonNavigatorAttribute");

        // for each syntax tree, find the class declarations that derive from the base types
        foreach (var syntaxTree in compilation.SyntaxTrees)
        {
            var root = syntaxTree.GetRoot();
            var semanticModel = compilation.GetSemanticModel(syntaxTree);
            var classDeclarations = root.DescendantNodes().OfType<ClassDeclarationSyntax>();

            // for each class declaration, check if it derives from any of the base types
            foreach (var classDeclaration in classDeclarations)
            {
                // get the symbol for the class declaration
                var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);

                var attributes = classSymbol.GetAttributes();
                var hasAttribute = attributes.Any(a => a.AttributeClass.Equals(skipBackButtonGenerationSymbol, SymbolEqualityComparer.Default));

                if (hasAttribute)
                {
                    // don't generate back button handling for this class
                    continue;
                }

                // check if the class symbol inherits from any of the base type symbols
                if (classSymbol.BaseType.Equals(contentPageSymbol, SymbolEqualityComparer.Default) ||
                    classSymbol.BaseType.Equals(flyoutPageSymbol, SymbolEqualityComparer.Default) ||
                    classSymbol.BaseType.Equals(navigationPageSymbol, SymbolEqualityComparer.Default) ||
                    classSymbol.BaseType.Equals(tabbedPageSymbol, SymbolEqualityComparer.Default))
                {
                    // get the name and namespace of the class symbol
                    var typeName = classSymbol.Name;
                    var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

                    // generate the source code for the HandleBackButtonPressed method
                    var sourceBuilder = $@"// <auto-generated>
//     This code was generated by a tool. Burkus.Mvvm.Maui generated this.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

namespace {namespaceName};

partial class {typeName}
{{
        protected override bool OnBackButtonPressed()
        {{
            return BackButtonNavigator.HandleBackButtonPressed();
        }}
}}";

                    // Add the source file to the generator output
                    context.AddSource($"{typeName}-HandleBackButton.g.cs", SourceText.From(sourceBuilder, Encoding.UTF8));
                }
            }
        }
    }
}
